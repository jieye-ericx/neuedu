# 复习切片
# 正向切(step为正)
# 原型l[start:end:step]

# 逆向切(step为负)
# 注意:取数据的方向和步长的方向一致的时候才能切出来


import numpy as np


# 总结:
# numpy数组和传统列表的区别和对比
# 1. np在创建的时候具有固定的大小 原生的列表(动态)
#    更改ndarray的大小,相当于重新创建了一个新的ndarray对象
# 2. numpy中的数据,都是具备同一个dtype 因为dtype类型一致, 间接的说明了ndarray对象在内存中的大小就一样
#    ps:python原生数组中包含ndarray, 内存中的大小就会发生大小不一
# 3. numpy中有大量的高级数学公式, 直接可以拿来使用,提高代码的效率

# l1 = [11, 22]
# l2 = l1[:]  # 浅复制
# print(l2)
# l2[0] = 666
# print(l2)
# print(l1)

# l1 = [11, 22, [33, 44]]
# l2 = l1[:]  # 浅复制
# print(l2)
# l2[2][0] = 666
# print(l2)
# print(l1)

# 1维 向量 只有0轴
# x = np.arange(10)
# print("原ndarray数组中的元素:")
# print(x)
#
# print(x.shape)
# print(x.ndim)

# x[2] = True
# print(x)

# x[3] = 12.33
# # print(x)

# print(x[1:4])
# print(x[:2])
#
# # 当给ndarray通过切片取出的元素赋值的时候属于原地操作
# # numpy用来处理大数据的,如果nunmpy和原生的python 列表一样,数据复制来复制去,那么就会产生内存和性能问题,这也是numpy快的一个原因
# x[3:6] = 999
# print(x)

# x_copy = x[3:6].copy()
# x_copy[0] = 999
# print(x_copy)
# print(x)


# 2维ndarray
# n2 = np.arange(15).reshape((3, 5))
# print("---------- 原矩阵n2 ------------")
# print(n2)


# n2 是二维的 根据形状推断出 两个轴即0轴跟1轴
# 对矩阵取值
# print(n2[0][1])    # 1
# print(n2[2, 3])    # 13


# n2[2, 3] = 100     # 原地操作
# print(n2)

# 切片
# print(n2[:2, :2])

# 尝试对子矩阵中的元素进行修改
# print("---------- 对n2的子矩阵修改后的 n2 -------------")
# n2[:2, :2][0][0] = 999
# print(n2)


# 3维 ndarray
n3 = np.arange(18).reshape(2, 3, 3)
print("-------------- 原矩阵n3 -------------")
print(n3)

# 3维矩阵取值
# print(n3[:1, :2, :3])

# 赋值子矩阵
# 需要注意的先看形状
# print(n3[:1, :2, :3].shape)

# n3[:1, :2, :3] = np.array([[11, 22, 33], [44, 55, 66]])
# print("-------------- 对子矩阵修改后的 n3矩阵 --------------")
# print(n3)


# print("------------------------")
# 取 0 1区域中的0, 1行 0,1列   ===> 子矩阵
# print(n3[:2, :2, :2])

# 对子矩阵进行赋值, 赋值的时候需要考虑子矩阵的深度,行,列 赋值的对象形状要与子矩阵完全一致
# n3[:2, :2, :2] = np.array([[[666, 6666], [999, 9999]]])
# print(n3)

# 带有深度的子矩阵操作赋值
# n3[:2, :2, :2] = np.arange(8).reshape(2, 2, 2)
# print(n3)


# 练习:
# 现有矩阵格式如下
# [[[1, 2, 3]
#   [4, 5, 6]
#   [7, 8, 9]]
#
#   [[10, 11, 12]
#    [13, 14, 15]
#    [16, 17, 18]]]

# 1. 截取子矩阵数据 5  6
#                  17 18
# 2. 替换子矩阵中的所有元素值
#
#  0区域中的 4, 5, 7, 8
#  1区域中的 13, 14, 16, 17
#  替换后对应区域的值修改为 44, 55, 77, 88
#                         133, 144, 166, 177


# 截取子矩阵
# print("-" * 10)
# # 取n3矩阵中0区域中的0, 1行 0,1列   ===> 子矩阵
# n4 = n3[:1, :2, :2]
# # 创建2维矩阵
# n5 = np.array([[11, 22], [33, 44]])
# # 将n5赋值给n4
# n4 = n5
# # 输出n4 此时n4中元素被替换为n5中的元素
# print(n4)
# print("-" * 10)
# # 修改n4矩阵中的元素
# n4[0][1] = 99999
# # 在输出n3中的矩阵
# print(n3)
